/*
* Copyright (c) 2009-2013 Yorba Foundation
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA 02110-1301 USA
*/

private class PrepareFilesJob : BackgroundImportJob {
    // Do not examine until the CompletionCallback has been called.
    public int prepared_files = 0;

    private Gee.List<FileToPrepare> files_to_prepare;
    private unowned NotificationCallback notification;
    private File library_dir;

    // these are for debugging and testing only
    private int import_file_count = 0;
    private int fail_every = 0;
    private int skip_every = 0;

    public PrepareFilesJob (BatchImport owner, Gee.List<FileToPrepare> files_to_prepare,
                            NotificationCallback notification, CompletionCallback callback, Cancellable cancellable,
                            CancellationCallback cancellation) {
        base (owner, callback, cancellable, cancellation);

        this.files_to_prepare = files_to_prepare;
        this.notification = notification;
        library_dir = AppDirs.get_import_dir ();
        fail_every = get_test_variable ("SHOTWELL_FAIL_EVERY");
        skip_every = get_test_variable ("SHOTWELL_SKIP_EVERY");

        set_notification_priority (Priority.LOW);
    }

    private static int get_test_variable (string name) {
        string value = Environment.get_variable (name);

        return (value == null || value.length == 0) ? 0 : int.parse (value);
    }

    public override void execute () {
        Timer timer = new Timer ();

        Gee.ArrayList<PreparedFile> list = new Gee.ArrayList<PreparedFile> ();
        foreach (FileToPrepare file_to_prepare in files_to_prepare) {
            ImportResult result = abort_check ();
            if (result != ImportResult.SUCCESS) {
                report_failure (file_to_prepare.job, null, file_to_prepare.job.get_dest_identifier (),
                                file_to_prepare.job.get_source_identifier (), result);

                continue;
            }

            BatchImportJob job = file_to_prepare.job;
            File? file = file_to_prepare.file;
            File ? associated = file_to_prepare.associated != null ? file_to_prepare.associated.file : null;
            bool copy_to_library = file_to_prepare.copy_to_library;

            // if no file seen, then it needs to be offered/generated by the BatchImportJob
            if (file == null) {
                if (!create_file (job, out file, out copy_to_library))
                    continue;
            }

            if (associated == null && file_to_prepare.associated != null) {
                create_file (file_to_prepare.associated.job, out associated, out copy_to_library);
            }

            PreparedFile prepared_file;
            result = prepare_file (job, file, associated, copy_to_library, out prepared_file);
            if (result == ImportResult.SUCCESS) {
                prepared_files++;
                list.add (prepared_file);
            } else {
                report_failure (job, file, job.get_source_identifier (), file.get_path (),
                                result);
            }

            if (list.size >= BatchImport.REPORT_EVERY_N_PREPARED_FILES
                    || ((timer.elapsed () * 1000.0) > BatchImport.REPORT_PREPARED_FILES_EVERY_N_MSEC && list.size > 0)) {
#if TRACE_IMPORT
                debug ("Notifying that %d prepared files are ready", list.size);
#endif
                PreparedFileCluster cluster = new PreparedFileCluster (list);
                list = new Gee.ArrayList<PreparedFile> ();
                notify (notification, cluster);
                timer.start ();
            }
        }

        if (list.size > 0) {
            ImportResult result = abort_check ();
            if (result == ImportResult.SUCCESS) {
                notify (notification, new PreparedFileCluster (list));
            } else {
                // subtract these, as they are not being submitted
                assert (prepared_files >= list.size);
                prepared_files -= list.size;

                foreach (PreparedFile prepared_file in list) {
                    report_failure (prepared_file.job, prepared_file.file,
                                    prepared_file.job.get_source_identifier (), prepared_file.file.get_path (),
                                    result);
                }
            }
        }
    }

    // If there's no file, call this function to get it from the batch import job.
    private bool create_file (BatchImportJob job, out File file, out bool copy_to_library) {
        try {
            if (!job.prepare (out file, out copy_to_library)) {
                report_failure (job, null, job.get_source_identifier (),
                                job.get_dest_identifier (), ImportResult.FILE_ERROR);

                return false;
            }
        } catch (Error err) {
            report_error (job, null, job.get_source_identifier (), job.get_dest_identifier (),
                          err, ImportResult.FILE_ERROR);

            return false;
        }
        return true;
    }

    private ImportResult prepare_file (BatchImportJob job, File file, File? associated_file,
                                       bool copy_to_library, out PreparedFile prepared_file) {
        prepared_file = null;

        bool is_video = VideoReader.is_supported_video_file (file);

        if ((!is_video) && (!Photo.is_file_image (file)))
            return ImportResult.NOT_AN_IMAGE;

        if ((!is_video) && (!PhotoFileFormat.is_file_supported (file)))
            return ImportResult.UNSUPPORTED_FORMAT;

        import_file_count++;

        // test case (can be set with SHOTWELL_FAIL_EVERY environment variable)
        if (fail_every > 0) {
            if (import_file_count % fail_every == 0)
                return ImportResult.FILE_ERROR;
        }

        // test case (can be set with SHOTWELL_SKIP_EVERY environment variable)
        if (skip_every > 0) {
            if (import_file_count % skip_every == 0)
                return ImportResult.NOT_A_FILE;
        }

        string exif_only_md5 = null;
        string thumbnail_md5 = null;
        string full_md5 = null;

        try {
            full_md5 = md5_file (file);
#if TRACE_MD5
            debug ("import MD5 for file %s = %s", file.get_path (), full_md5);
#endif
        } catch (Error err) {
            warning ("Unable to perform MD5 checksum on file %s: %s", file.get_path (),
                     err.message);

            return ImportResult.convert_error (err, ImportResult.FILE_ERROR);
        }

        // we only care about file extensions and metadata if we're importing a photo --
        // we don't care about these things for video
        PhotoFileFormat file_format = PhotoFileFormat.get_by_file_extension (file);
        if (!is_video) {
            if (file_format == PhotoFileFormat.UNKNOWN) {
                warning ("Skipping %s: unrecognized file extension", file.get_path ());

                return ImportResult.UNSUPPORTED_FORMAT;
            }
            PhotoFileReader reader = file_format.create_reader (file.get_path ());
            PhotoMetadata? metadata = null;
            try {
                metadata = reader.read_metadata ();
            } catch (Error err) {
                warning ("Unable to read metadata for %s (%s): continuing to attempt import",
                         file.get_path (), err.message);
            }

            if (metadata != null) {
                uint8[]? flattened_sans_thumbnail = metadata.flatten_exif (false);
                if (flattened_sans_thumbnail != null && flattened_sans_thumbnail.length > 0)
                    exif_only_md5 = md5_binary (flattened_sans_thumbnail, flattened_sans_thumbnail.length);

                uint8[]? flattened_thumbnail = metadata.flatten_exif_preview ();
                if (flattened_thumbnail != null && flattened_thumbnail.length > 0)
                    thumbnail_md5 = md5_binary (flattened_thumbnail, flattened_thumbnail.length);
            }
        }

        uint64 filesize = 0;
        try {
            filesize = query_total_file_size (file, get_cancellable ());
        } catch (Error err) {
            warning ("Unable to query file size of %s: %s", file.get_path (), err.message);

            return ImportResult.convert_error (err, ImportResult.FILE_ERROR);
        }

        // never copy file if already in library directory
        bool is_in_library_dir = file.has_prefix (library_dir);

        // notify the BatchImport this is ready to go
        prepared_file = new PreparedFile (job, file, associated_file, job.get_source_identifier (),
                                          job.get_dest_identifier (), copy_to_library && !is_in_library_dir, exif_only_md5,
                                          thumbnail_md5, full_md5, file_format, filesize, is_video);

        return ImportResult.SUCCESS;
    }
}
